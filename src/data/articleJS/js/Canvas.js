export default "# 初始化\n\n```\nconst canvasDomEle = document.querySelector('#myCanvas')\nconst ctx = canvasDomEle.getContext('2d')\n```\n\n# 颜色、样式和阴影\n\n## 属性\n\n* fillStyle  // 设置或返回用于填充绘画的颜色、渐变或模式\n* strokeStyle  // 设置或返回用于笔触的颜色、渐变或模式\n* shadowColor  // 设置或返回用于阴影的颜色\n* shadowBlur  // 设置或返回用于阴影的模糊级别\n* shadowOffsetX  // 设置或返回阴影与形状的水平距离\n* shadowOffsetY  // 设置或返回阴影与形状的垂直距离\n\n```\nctx.fillStyle = color | gradient | pattern\nctx.strokeStyle = color | gradient | pattern\nctx.shadowColor = color\nctx.shadowBlur = number\nctx.shadowOffsetX = number\nctx.shadowOffsetY = number\n```\n\n## 方法\n\n* createLinearGradient()  // 创建线性渐变（用在画布内容上）\n* createRadialGradient()  // 创建放射状/环形的渐变（用在画布内容上）\n* addColorStop()  // 规定渐变对象中的颜色和停止位置\n* createPattern()  // 在指定的方向上重复指定的元素\n\n```\nconst gradient = ctx.createLinearGradient(x0, y0, x1, y1)\nconst gradient = ctx.createRadialGradient(x0, y0, r0, x1, y1, r1)\n\ngradient.addColorStop(stop, color) // stop: [0, 1]\n\nconst pattern = ctx.createPattern(imgDom, 'repeat | repeat-x | repeat-y | no-repeat')\n```\n\n# 线条样式\n\n## 属性\n\n* lineCap  // 设置或返回线条的结束端点样式\n* lineJoin  // 设置或返回两条线相交时，所创建的拐角类型\n* lineWidth  // 设置或返回当前的线条宽度\n* miterLimit  // 设置或返回最大斜接长度\n\n```\nctx.lineCap = 'butt | round | square'\nctx.lineJoin = 'miter | bevel | round' // 斜切 | 锥角 | 圆角\nctx.lineWidth = number\nctx.miterLimit = number // ctx.lineJoin = 'miter'\n```\n\n# 矩形\n\n## 方法\n\n* rect()  // 创建矩形\n* fillRect()  // 绘制\"被填充\"的矩形\n* strokeRect()  // 绘制矩形（无填充）\n* clearRect()  // 在给定的矩形内清除指定的像素\n\n```\nctx.rect(x, y, width, height)\nctx.fillRect(x, y, width, height)\nctx.strokeRect(x, y, width, height)\nctx.clearRect(x, y, width, height)\n```\n\n# 路径\n\n## 方法\n\n* beginPath()  // 起始一条路径，或重置当前路径\n* lineTo()  // 添加一个新点，然后在画布中创建从该点到最后指定点的线条\n* moveTo()  // 把路径移动到画布中的指定点，不创建线条\n* closePath()  // 创建从当前点回到起始点的路径\n\n* fill()  // 填充当前绘图（路径）\n* stroke()  // 绘制已定义的路径\n\n* clip()  // 从原始画布剪切任意形状和尺寸的区域\n\n* quadraticCurveTo()  // 创建二次贝塞尔曲线\n* bezierCurveTo()  // 创建三次贝塞尔曲线\n* arc()  // 创建弧/曲线（用于创建圆形或部分圆）\n* arcTo()  // 创建两切线之间的弧/曲线\n* isPointInPath()  // 如果指定的点位于当前路径中，则返回 true，否则返回 false\n\n```\nctx.beginPath()\nctx.lineTo(x, y)\nctx.moveTo(x, y)\nctx.closePath()\n\nctx.fill()\nctx.stroke()\n\nctx.clip()\n\nctx.quadraticCurveTo(cpx, cpy, x, y)\nctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)\n\nctx.arc(x, y, r, startAngle, endAngle, counterclockwise) // counterclockwise=true 逆时针\nctx.arcTo(x1, y1, x2, y2, r)\nctx.isPointInPath(x, y)\n```\n\n# 转换\n\n## 方法\n\n* scale()  // 缩放当前绘图至更大或更小\n* rotate()  // 旋转当前绘图\n* translate()  // 重新映射画布上的 (0,0) 位置\n* transform()  // 替换绘图的当前转换矩阵\n* setTransform()  // 将当前转换重置为单位矩阵然后运行 transform()\n\n```\nctx.scale(scaleWidth, scaleHeight)\nctx.rotate(angle)\nctx.transform(a, b, c, d, e, f) // x缩放 | x倾斜 | y缩放 | y倾斜 | x平移 | y平移\nctx.setTransform(a, b, c, d, e, f) // x缩放 | x倾斜 | y缩放 | y倾斜 | x平移 | y平移\n```\n\n# 文本\n\n## 属性\n\n* font  // 设置或返回文本内容的当前字体属性\n* textAlign  // 设置或返回文本内容的当前对齐方式\n* textBaseline  // 设置或返回在绘制文本时使用的当前文本基线\n\n```\nctx.font = 'font-style font-variant font-weight font-size/line-height font-family'\nctx.textAlign = 'center | end | left | right | start'\nctx.textBaseline = 'alphabetic | top | hanging | middle | ideographic | bottom'\n```\n\n## 方法\n\n* fillText()  // 在画布上绘制\"被填充的\"文本\n* strokeText()  // 在画布上绘制文本（无填充）\n* measureText()  // 返回包含指定文本宽度的对象\n\n```\nctx.fillText(text, x, y, maxWidth)\nctx.strokeText(text, x, y, maxWidth)\nconst measureTextWidth = ctx.measureText(text).width\n\nTextMetrics {\n    width [num]\n}\n```\n\n# 图像绘制\n\n## 方法\n\n* drawImage(imgDom, sx, sy, swidth, sheight, x, y, width, height)  // 向画布上绘制图像、画布或视频\n\n```\ndrawImage(imgDom, x, y)\ndrawImage(imgDom, x, y, width, height)\ndrawImage(imgDom, sx, sy, swidth, sheight, x, y, width, height)\n```\n\n# 像素操作 ImageData\n\n## 属性\n\n* width/height  // 返回 ImageData 对象的宽度/高度\n* data  // 返回一个对象，其包含指定的 ImageData 对象的图像数据\n\n```\nImageData {\n    width [int]\n    height [int]\n    data [Uint8ClampedArray]\n}\n```\n\n## 方法\n\n* createImageData()  // 创建新的、空白的 ImageData 对象\n* getImageData()  // 返回 ImageData 对象，该对象为画布上指定的矩形复制像素数据\n* putImageData()  // 把图像数据（从指定的 ImageData 对象）放回画布上\n\n```\nconst imgData = ctx.createImageData(width, height)\nconst imgData = ctx.createImageData(imgData0)\n\nconst imgData = ctx.getImageData(x, y, width, height)\n\nctx.putImageData(imgData, x, y, dirtyX, dirtyY, dirtyWidth, dirtyHeight)\n```\n\n# 其他\n\n* getContext()\n* toDataURL()\n* save()\n* restore()\n* createEvent()\n\n```\ncanvasDomEle.getContext('2d')\ncanvasDomEle.toDataURL()\n```\n\n# Reference\n\n* [http://www.runoob.com/tags/ref-canvas.html](http://www.runoob.com/tags/ref-canvas.html)\n"